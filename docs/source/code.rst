Source documentation
====================

Below, you can find a detailed description of the different parts to be added to your code, when interfacing Geant4 with Garfield++ and/or Degrad. The project contains four different interfacing models. Two of them are used to model events in a charge sensitive TPC and the remaining two are used to model a Xenon-based optical TPC. All code snippets are copied from the source code.

DetectorConstruction
-----------------------------

As mentioned above, the project involves two user cases: a TPC with charged readout and an optical TPC. The first one uses the setup from the ALICE TPC and generally follows the online example from the Garfield_ webpage. 

.. _Garfield: http://garfieldpp.web.cern.ch/garfieldpp/examples/alicetpc/

The following lines should be added to the *Construct*-method of your *G4VDetectorConstruction*-derived class, as a way to create a region where the Interface model should be applied.

.. code-block:: cpp

   G4VPhysicalVolume* DetectorConstruction::Construct(){
      ...
      G4Region* regionGas = new G4Region("GasRegion");
      regionGas->AddRootLogicalVolume(logicGasBox);
   }
   
Evidently, **logicGasBox** is the *G4LogicalVolume* assigned to the gas volume.

For the purpos of making the project multi-threaded, it is desirable to implement the G4VFastSimulationModels in the *ConstructSDandField*-method. However, keep in mind that currently Heed, which is part of Garfield++ and extensively used in the Interface-project, does not support multi-threading. The method should contain the following

.. code-block:: cpp

   void DetectorConstruction::ConstructSDandField(){
      G4SDManager* SDManager = G4SDManager::GetSDMpointer();
      G4String GasBoxSDname = "interface/GasBoxSD";
      GasBoxSD* myGasBoxSD = new GasBoxSD(GasBoxSDname);
      SDManager->SetVerboseLevel(1);
      SDManager->AddNewDetector(myGasBoxSD);
      SetSensitiveDetector(logicGasBox,myGasBoxSD);
      ...
      G4Region* region = G4RegionStore::GetInstance()->GetRegion("GasRegion");
      new HeedOnlyModel(fGasModelParameters,"HeedOnlyModel",region,this,myGasBoxSD);
      new HeedInterfaceModel(fGasModelParameters,"HeedInterfaceModel",region,this,myGasBoxSD);
      new DegradModel(fGasModelParameters,"DegradModel",region,this,myGasBoxSD);
      new GarfieldVUVPhotonModel(fGasModelParameters,"GarfieldVUVPhotonModel",region,this,myGasBoxSD);
   }
   
Here, the *G4VSensitiveDetector* **GasBoxSD** is used to record the data generated by the Interface models. Therefore, it is supplied as an argument to the model constructors.

PhysicsList
-----------------

As of release 10.4, the implementation of parametrised physics models has changed quite a lot and a messenger class was added to give more control to the user. One of the changes is the implementation of a *G4FastSimulationPhysics*-class which basically operates in the same way as any other physics list: it contains a *ConstructParticle*- and a *ConstructProcess*-method, and derives from the *G4VPhysicsConstructor* parent class. Hence, to add the parametrised physics model to your physics list, its constructor should contain the following lines

.. code-block:: cpp

   PhysicsList::PhysicsList(){
      ...
      fastSimulationPhysics = new G4FastSimulationPhysics("fastSimPhys");
      RegisterPhysics(fastSimulationPhysics);
   }
   
Where **fastSimulationPhysics** is a member of the *G4FastSimulationPhysics*-class and added as an object to the *PhysicsList*-class. At this moment the user has added the fast simulation physics to the physics list, but there are now particles to which it shall be applied. This is accomodated by a third method in the *G4FastSimulationPhysics*-class:

.. code-block:: cpp

   void G4FastSimulationPhysics::ActivateFastSimulation(const G4String& particleName)
   
In the Interface code, this is implemented in a separate method, *AddParametrisation*:

.. code-block:: cpp

   void PhysicsList::AddParametrisation() {   
      theParticleTable->GetIterator()->reset();
      while ((*theParticleTable->GetIterator())()) {
         G4String particleName = theParticleTable->GetIterator()->value()->GetParticleName();
         fastSimulationPhysics->ActivateFastSimulation(particleName);
      }
   }
   
In order to give the user more control, a messenger-class(*PhysicsListMessenger*) was created for the *PhysicsList*-class. One of the commands in this messenger calls the *AddParametrisation*-method:

.. code-block:: cpp
   
   /InterfaceExample/phys/AddParametrisation
   
Since this command adds all the particles to the user's *G4FastSimulationPhysics*-class, it should be run before the */run/initialize*-command, as this will call the *ConstructProcess*-method of all registered physics lists. The user may also decide here to implement a messenger command to add specific particles only. The author, however, decided to leave the control of this aspect to a different class, i.e. *GasModelParametersMessenger*.

One last line of code, important for the interface code, is the following

.. code-block:: cpp

   G4ProductionCutsTable::GetProductionCutsTable()->SetEnergyRange(lowE, 100. * MeV);

Where the variable, *lowE*, sets the minimum energy below which a secondary particle is not created when proposed by the step. Instead of producing a secondary, the energy initially reserved to create the secondary particle, is merely registered as deposited, and no secondary particle is produced. By default, this limit is put to 0.99 keV and it overwrites any range cut, for which the converted energy value lies below this minimum. As a primary charged particle propagates through a gas, it will create ionization along its way. Most of the created secondary electrons will be low in energy, i.e. below 100 eV, and are therefore not produced by default in Geant4. Only if *lowE* is set to a proper value, sufficient ionization will occur. How to set this value is explained in detail in the paper (arXiv_).

.. _arXiv: https://arxiv.org/abs/1806.05880

G4VFastSimulationModel
------------------------------------

There are four different *G4VFastSimulationModel*-objects in the project, three of them using Heed and/or Garfield++, and one of them using Degrad.
   



   
   

