Source documentation
====================

Below, you can find a detailed description of the different parts to be added to your code, when interfacing Geant4 with Garfield++ and/or Degrad. The project contains four different interfacing models. Two of them are used to model events in a charge sensitive TPC and the remaining two are used to model a Xenon-based optical TPC. All code snippets are copied from the source code.

DetectorConstruction
-----------------------------

The following lines should be added to the *Construct*-method of your *G4VDetectorConstruction*-derived class, as a way to create a region where the Interface model should be applied.

.. code-block:: cpp

   G4VPhysicalVolume* DetectorConstruction::Construct(){
      ...
      G4Region* regionGas = new G4Region("GasRegion");
      regionGas->AddRootLogicalVolume(logicGasBox);
   }
   
Evidently, **logicGasBox** is the *G4LogicalVolume* assigned to the gas volume.

For the purpos of making the project multi-threaded, it is desirable to implement the G4VFastSimulationModels in the *ConstructSDandField*-method. However, keep in mind that currently Heed, which is part of Garfield++ and extensively used in the Interface-project, does not support multi-threading. The method should contain the following

.. code-block:: cpp

   void DetectorConstruction::ConstructSDandField(){
      G4SDManager* SDManager = G4SDManager::GetSDMpointer();
      G4String GasBoxSDname = "interface/GasBoxSD";
      GasBoxSD* myGasBoxSD = new GasBoxSD(GasBoxSDname);
      SDManager->SetVerboseLevel(1);
      SDManager->AddNewDetector(myGasBoxSD);
      SetSensitiveDetector(logicGasBox,myGasBoxSD);
      ...
      G4Region* region = G4RegionStore::GetInstance()->GetRegion("GasRegion");
      new HeedNewTrackModel(fGasModelParameters,"HeedNewTrackModel",region,this,myGasBoxSD);
      new HeedDeltaElectronModel(fGasModelParameters,"HeedDeltaElectronModel",region,this,myGasBoxSD);
      new DegradModel(fGasModelParameters,"DegradModel",region,this,myGasBoxSD);
      new GarfieldVUVPhotonModel(fGasModelParameters,"GarfieldVUVPhotonModel",region,this,myGasBoxSD);
   }
   
Here, the *G4VSensitiveDetector* **GasBoxSD** is used to record the data generated by the Interface models. Therefore, it is supplied as an argument to the model constructors.

PhysicsList
-----------------

As of release 10.4, the implementation of parametrised physics models has changed quite a lot and a messenger class was added to give more control to the user. One of the changes is the implementation of a *G4FastSimulationPhysics*-class which basically operates in the same way as any other physics list: it contains a *ConstructParticle*- and a *ConstructProcess*-method, and derives from the *G4VPhysicsConstructor* parent class. Hence, to add the parametrised physics model to your physics list, its constructor should contain the following lines

.. code-block:: cpp

   PhysicsList::PhysicsList(){
      ...
      fastSimulationPhysics = new G4FastSimulationPhysics("fastSimPhys");
      RegisterPhysics(fastSimulationPhysics);
   }
   
Where **fastSimulationPhysics** is a member of the *G4FastSimulationPhysics*-class and added as an object to the *PhysicsList*-class. At this moment the user has added the fast simulation physics to the physics list, but there are now particles to which it shall be applied. This is accomodated by a third method in the *G4FastSimulationPhysics*-class:

.. code-block:: cpp

   void G4FastSimulationPhysics::ActivateFastSimulation(const G4String& particleName)
   
In the Interface code, this is implemented in a separate method, *AddParametrisation*:

.. code-block:: cpp

   void PhysicsList::AddParametrisation() {   
      theParticleTable->GetIterator()->reset();
      while ((*theParticleTable->GetIterator())()) {
         G4String particleName = theParticleTable->GetIterator()->value()->GetParticleName();
         fastSimulationPhysics->ActivateFastSimulation(particleName);
      }
   }
   
In order to give the user more control, a messenger-class(*PhysicsListMessenger*) was created for the *PhysicsList*-class. One of the commands in this messenger calls the *AddParametrisation*-method:

.. code-block:: cpp
   
   /InterfaceExample/phys/AddParametrisation
   
Since this command adds all the particles to the user's *G4FastSimulationPhysics*-class, it should be run before the */run/initialize*-command, as this will call the *ConstructProcess*-method of all registered physics lists. The user may also decide here to implement a messenger command to add specific particles only. The author, however, decided to leave the control of this aspect to a different class, i.e. *GasModelParametersMessenger*.

One last line of code, important for the interface code, is the following

.. code-block:: cpp

   G4ProductionCutsTable::GetProductionCutsTable()->SetEnergyRange(lowE, 100. * MeV);

Where the variable, *lowE*, sets the minimum energy below which a secondary particle is not created when proposed by the step. Instead of producing a secondary, the energy initially reserved to create the secondary particle, is merely registered as deposited, and no secondary particle is produced. By default, this limit is put to 0.99 keV and it overwrites any range cut, for which the converted energy value lies below this minimum. As a primary charged particle propagates through a gas, it will create ionization along its way. Most of the created secondary electrons will be low in energy, i.e. below 100 eV, and are therefore not produced by default in Geant4. Only if *lowE* is set to a proper value, sufficient ionization will occur. How to set this value is explained in detail in the paper (arXiv_).

.. _arXiv: https://arxiv.org/abs/1806.05880

G4VFastSimulationModel
------------------------------------

There are four different *G4VFastSimulationModel*-objects in the project, three of them using Heed/Garfield++, and one of them using Degrad, each of which following one of the paths in the flow charts for :ref:`chargedParticles` and :ref:`photons` . The first two, *HeedNewTrackModel* and *HeedDeltaElectronModel*, both derive from class *HeedModel*, which in turn derives from the *G4VFastSimulationModel*-class. They are applied in conjunction with the :ref:`alicetpc` setup. Whereas the former follows the green path in the flow chart for charged particles, the latter follows the red path. The other two models are designed for the :ref:`opticaltpc` setup, and are called *DegradModel* and *GarfieldVUVPhotonModel*

All models derive from the *G4VFastSimulationModel*-class, and should overwrite the following virtual methods:

   - *IsApplicable(const G4ParticleDefinition&)*
   - *ModelTrigger(const G4FastTrack&)*
   - *DoIt(const G4FastTrack&, G4FastStep&)*
   
The first method is called for each new track and checks if the model is applicable for a certain particle type. If so it should return *true*, otherwise it should return *false*. The second method is called in each step (of course only if *IsApplicable* has returned *true* for the track), and is used to check if the track conditions for triggering the model are fullfilled. The third method contains the actual model.

*HeedNewTrackModel* and *HeedDeltaElectronModel* follow the same approach with respect to the first two methods. The user can provide the particle names together with lower and upper thresholds for the energy, as explained in :ref:`macro-label`. Each particle added to the model is saved in a map together with the corresponding energy thresholds. When a new track enters the gas region, the *IsApplicable*-method is called, which itself calls the internal method *FindParticleName(G4String particleName)*. The latter will search the map for *particleName* and returns *true* if present. The method *FindParticleNameEnergy(G4String particleName, double eKin)*, which is called by the *ModelTrigger*-method, will search the map for *particleName* with an energy *eKin* that lies in between the lower and upper threshold, and returns *true* if present. The larger part of the *DoIt*-method is also the same for both methods. The difference is in the *Run*-method called at the second to last line:

.. code-block:: cpp

   void HeedModel::DoIt(const G4FastTrack& fastTrack, G4FastStep& fastStep) {
      G4ThreeVector localdir = fastTrack.GetPrimaryTrackLocalDirection();
      G4ThreeVector worldPosition = fastTrack.GetPrimaryTrack()->GetPosition();
      G4double ekin = fastTrack.GetPrimaryTrack()->GetKineticEnergy();
      G4double time = fastTrack.GetPrimaryTrack()->GetGlobalTime();
      G4String particleName =
      fastTrack.GetPrimaryTrack()->GetParticleDefinition()->GetParticleName();
      fastStep.KillPrimaryTrack();
      fastStep.SetPrimaryTrackPathLength(0.0);
      Run(particleName, ekin/keV, time, worldPosition.x() / CLHEP::cm,
               worldPosition.y() / CLHEP::cm, worldPosition.z() / CLHEP::cm,
               localdir.x(), localdir.y(), localdir.z());
      fastStep.SetTotalEnergyDeposited(ekin);
   }
   
The *Run*-method of the *HeedNewTrackModel*-class calls *NewTrack*, which is a member of the Garfield++ *TrackHeed*-class and is actually itself an interface class between Garfield++ and Heed. This method is intended for high energy charged particles in relatively thin gas absorbers as it does not take into account coulomb scattering. The *Run*-method of the *HeedDeltaElectronModel*-class calls *TransportDeltaElectron* (or *TransportPhoton* if the particle is a gamma-ray). This method does take into account coulomb scattering and is therefore intended for low energy particles. As shown in the paper, the *HeedDeltaElectronModel* should not be used for energies higher than a few tens of keV, as the simulated energy deposition by the primary particle will be off.




   
   

